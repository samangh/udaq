#include "udaq/helpers/visa.h"

std::string udaq::visa::get_visa_code_description(int return_code)
{
    switch(return_code){
    case VI_SUCCESS: return "Operation completed successfully.";
    case VI_SUCCESS_DEV_NPRESENT: return "Session opened successfully, but the device at the specified address is not responding.";
    case VI_SUCCESS_EVENT_DIS: return "The specified event is already disabled.";
    case VI_SUCCESS_EVENT_EN: return "The specified event is already enabled for at least one of the specified mechanisms.";
    case VI_SUCCESS_MAX_CNT: return "The number of bytes specified were read.";
    case VI_SUCCESS_NCHAIN: return "Event handled successfully. Do not invoke any other handlers on this session for this event.";
    case VI_SUCCESS_NESTED_EXCLUSIVE: return "The specified access mode was successfully acquired and this session has nested exclusive locks.";
    case VI_SUCCESS_NESTED_SHARED: return "The specified access mode was successfully acquired and this session has nested shared locks.";
    case VI_SUCCESS_QUEUE_EMPTY: return "The event queue was empty while trying to discard queued events.";
    case VI_SUCCESS_QUEUE_NEMPTY: return "The event queue is not empty.";
    case VI_SUCCESS_SYNC: return "The read or write operation performed synchronously.";
    case VI_SUCCESS_TERM_CHAR: return "The specified termination character was read.";
    case VI_SUCCESS_TRIG_MAPPED: return "The path from trigSrc to trigDest is already mapped.";
    case VI_WARN_CONFIG_NLOADED: return "The specified configuration either does not exist or could not be loaded using VISA-specified defaults.";
    case VI_WARN_NSUP_ATTR_STATE: return "The attribute state is not supported by this resource.";
    case VI_WARN_NSUP_BUF: return "The specified buffer is not supported.";
    case VI_WARN_NULL_OBJECT: return "The specified object reference is uninitialized.";
    case VI_WARN_QUEUE_OVERFLOW: return "The device sent more data than the user specified in VI_ATTR_USB_MAX_INTR_SIZE";
    case VI_WARN_UNKNOWN_STATUS: return "The status code passed to the function was unable to be interpreted.";
    case VI_WARN_EXT_FUNC_NIMPL: return "The operation succeeded, but a lower level driver did not implement the extended functionality";
    case VI_ERROR_ABORT: return "Calls in the current process executing on the specified vi are aborted.";
    case VI_ERROR_ALLOC: return "Insufficient system resources to open a session or to allocate the buffer(s) or memory block of the specified size.";
    case VI_ERROR_ASRL_FRAMING: return "A framing error occurred during transfer.";
    case VI_ERROR_ASRL_OVERRUN: return "An overrun error occurred during transfer. A character was not read from the hardware before the next character arrived.";
    case VI_ERROR_ASRL_PARITY: return "A parity error occurred during transfer.";
    case VI_ERROR_ATTR_READONLY: return "The specified attribute is read-only.";
    case VI_ERROR_BERR: return "A bus error occurred during transfer.";
    case VI_ERROR_CLOSING_FAILED: return "Unable to deallocate the previously allocated data structures for this session.";
    case VI_ERROR_CONN_LOST: return "A TCP connection is dropped as a result of keep-alives packets.";
    case VI_ERROR_FILE_ACCESS: return "An error occurred while trying to open the specified file. Possible reasons include an invalid path or lack of access rights.";
    case VI_ERROR_FILE_IO: return "An error occurred while accessing the specified file.";
    case VI_ERROR_HNDLR_NINSTALLED: return "A handler is not currently installed for the specified event. The session cannot be enabled for the VI_HNDLR mode of the callback mechanism.";
    case VI_ERROR_INP_PROT_VIOL: return "Input protocol error occurred during transfer.";
    case VI_ERROR_INTF_NUM_NCONFIG: return "The interface type is valid but the specified interface number is not configured.";
    case VI_ERROR_INTR_PENDING: return "An interrupt is still pending from a previous call.";
    case VI_ERROR_INV_ACC_MODE: return "Invalid access mode.";
    case VI_ERROR_INV_ACCESS_KEY: return "The requestedKey value passed in is not a valid access key to the specified resource.";
    case VI_ERROR_INV_CONTEXT: return "The event context specified is invalid.";
    case VI_ERROR_INV_DEGREE: return "The specified degree is invalid.";
    case VI_ERROR_INV_EVENT: return "The event type specified is invalid for the specified resource.";
    case VI_ERROR_INV_EXPR: return "The expression specified is invalid.";
    case VI_ERROR_INV_FMT: return "The format specifier is invalid for the current argument.";
    case VI_ERROR_INV_HNDLR_REF: return "The specified handler reference and/or the user context value does not match the installed handler.";
    case VI_ERROR_INV_JOB_ID: return "The specified job identifier is invalid.";
    case VI_ERROR_INV_LENGTH: return "The length specified is invalid.";
    case VI_ERROR_INV_LINE: return "The value specified by the line parameter is invalid.";
    case VI_ERROR_INV_LOCK_TYPE: return "The specified type of lock is not supported by this resource.";
    case VI_ERROR_INV_MASK: return "The system cannot set the buffer for the given mask or the specified mask does not specify a valid flush operation on the read/write resource.";
    case VI_ERROR_INV_MECH: return "The mechanism specified for the event is invalid.";
    case VI_ERROR_INV_MODE: return "The value specified by the mode parameter is invalid.";
    case VI_ERROR_INV_OFFSET: return "The offset specified is invalid.";
    case VI_ERROR_INV_PARAMETER: return "The value of some parameter is invalid.";
    case VI_ERROR_INV_PROT: return "The protocol specified is invalid.";
    case VI_ERROR_INV_RSRC_NAME: return "The resources specified are invalid.";
    case VI_ERROR_INV_SESSION: return "The session specified is invalid.";
    case VI_ERROR_INV_SETUP: return "The setup specified is invalid, possibly due to attributes being set to an inconsistent state, or some implementation-specific configuration file is corrupt or does not exist.";
    case VI_ERROR_INV_SIZE: return "The specified size is invalid.";
    case VI_ERROR_INV_SPACE: return "The address space specified is invalid.";
    case VI_ERROR_INV_WIDTH: return "Invalid source or destination width specified.";
    case VI_ERROR_IO: return "Could not perform read/write function because of an I/O error, or an unknown I/O error occurred during transfer.";
    case VI_ERROR_LIBRARY_NFOUND: return "A code library required by VISA could not be located or loaded.";
    case VI_ERROR_LINE_IN_USE: return "The specified trigger line is in use.";
    case VI_ERROR_MEM_NSHARED: return "The device does not export any memory.";
    case VI_ERROR_NCIC: return "The session is referring to something other than the controller in charge.";
    case VI_ERROR_NENABLED: return "The session must be enabled for events of the specified type to receive them.";
    case VI_ERROR_NIMPL_OPER: return "The given operation is not implemented.";
    case VI_ERROR_NLISTENERS: return "No listeners are detected. (Both NRFD and NDAC are deasserted.)";
    case VI_ERROR_NPERMISSION: return "You do not have permission to perform this operation.";
    case VI_ERROR_NSUP_ALIGN_OFFSET: return "The specified offset is not properly aligned for the access width of the operation.";
    case VI_ERROR_NSUP_ATTR: return "The attribute specified is not supported by the specified resource.";
    case VI_ERROR_NSUP_ATTR_STATE: return "The state specified for the attribute is not supported.";
    case VI_ERROR_NSUP_FMT: return "The format specifier is not supported for the current argument type.";
    case VI_ERROR_NSUP_INTR: return "The interface cannot generate an interrupt on the requested level or with the requested statusID value.";
    case VI_ERROR_NSUP_LINE: return "One of the specified lines (trigSrc or trigDest) is not supported by this VISA implementation.";
    case VI_ERROR_NSUP_MECH: return "The specified mechanism is not supported for the given event type.";
    case VI_ERROR_NSUP_MODE: return "The specified mode is not supported by this VISA implementation.";
    case VI_ERROR_NSUP_OFFSET: return "The offset specified is not accessible.";
    case VI_ERROR_NSUP_OPER: return "The operation specified is not supported in the given session.";
    case VI_ERROR_NSUP_VAR_WIDTH: return "Cannot support source and destination widths that are different.";
    case VI_ERROR_NSUP_WIDTH: return "The specified width is not supported by this hardware.";
    case VI_ERROR_NSYS_CNTLR: return "The interface associated with this session is not the system controller.";
    case VI_ERROR_OUTP_PROT_VIOL: return "Output protocol error occurred during transfer.";
    case VI_ERROR_QUEUE_ERROR: return "Unable to queue read or write operation.";
    case VI_ERROR_RAW_RD_PROT_VIOL: return "A violation of raw read protocol occurred during a transfer.";
    case VI_ERROR_RAW_WR_PROT_VIOL: return "A violation of raw write protocol occurred during a transfer.";
    case VI_ERROR_RESP_PENDING: return "A previous response is still pending, causing a multiple query error.";
    case VI_ERROR_RSRC_BUSY: return "The resource is valid, but VISA cannot currently access it.";
    case VI_ERROR_RSRC_LOCKED: return "The specified operation could not be performed because the resource identified by vi has been locked for this kind of access.";
    case VI_ERROR_RSRC_NFOUND: return "The expression specified does not match any device, or resource was not found.";
    case VI_ERROR_SESN_NLOCKED: return "The current session did not have any lock on the resource.";
    case VI_ERROR_SYSTEM_ERROR: return "Unknown system error.";
    case VI_ERROR_TMO: return "The operation failed to complete within the specified timeout period.";
    case VI_ERROR_TRIG_NMAPPED: return "The path from trigSrc to trigDest is not currently mapped.";
    case VI_ERROR_USER_BUF: return "A specified user buffer is not valid or cannot be accessed for the required size.";
    case VI_ERROR_WINDOW_MAPPED: return "The specified session already contains a mapped window.";
    case VI_ERROR_WINDOW_NMAPPED: return "The specified session is not currently mapped.";
    case VI_ERROR_IN_PROGRESS: return "Unable to start a new asynchronous operation while another asynchronous operation is in progress";
    }

    return "Unknown error code " + std::to_string(return_code);
}
